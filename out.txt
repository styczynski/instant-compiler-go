[K[36mRead input[m  | Add intro for &{{custom.lat:2:8 custom.lat:2:12} %!s(*string=<nil>) %!s(*int64=<nil>) %!s(*string=<nil>) %!s(*bool=0xc0002fd618) %!s(*ast.Expression=<nil>) %!s(*ast.Index=&{{{custom.lat 22 2 8} {custom.lat 26 2 12}} 0xc000395c20 <nil> 0xc000395cc0}) %!s(*ast.PrimaryInvalid=<nil>) <nil>}
Add intro for &{{custom.lat:3:16 custom.lat:3:17} %!s(*string=<nil>) %!s(*int64=0xc0002fd5c8) %!s(*string=<nil>) %!s(*bool=<nil>) %!s(*ast.Expression=<nil>) %!s(*ast.Index=&{{{custom.lat 45 3 16} {custom.lat 46 3 17}} 0xc000395f40 <nil> 0xc0003e8000}) %!s(*ast.PrimaryInvalid=<nil>) <nil>}
Add intro for &{{custom.lat:3:16 custom.lat:3:17} %!s(*string=<nil>) %!s(*int64=0xc0002fd5c8) %!s(*string=<nil>) %!s(*bool=<nil>) %!s(*ast.Expression=<nil>) %!s(*ast.Index=&{{{custom.lat 45 3 16} {custom.lat 46 3 17}} 0xc000395f40 <nil> 0xc0003e8000}) %!s(*ast.PrimaryInvalid=<nil>) int}
Add intro for &{{custom.lat:1:1 custom.lat:49:1} {{custom.lat:1:1 custom.lat:1:5} %!s(*string=0xc00030d290) %!s(*ast.Accessor=<nil>) <nil>} r [%!s(*ast.Arg=&{{{custom.lat 6 1 7} {custom.lat 11 1 12}} {{{custom.lat 6 1 7} {custom.lat 10 1 11}} 0xc00030d2f0 <nil> <nil>} x <nil>})] %!s(*ast.Block=&{{{custom.lat 13 1 14} {custom.lat 901 49 1}} [0xc00026e840] 0xc0003c6120}) %!s(*ast.TopDef=&{{{custom.lat 0 1 1} {custom.lat 901 49 1}} <nil> 0xc0003c6120 0xc00038e280}) <nil>}
Add intro for &{{custom.lat:1:1 custom.lat:49:1} {{custom.lat:1:1 custom.lat:1:5} %!s(*string=0xc00030d290) %!s(*ast.Accessor=<nil>) <nil>} r [%!s(*ast.Arg=&{{{custom.lat 6 1 7} {custom.lat 11 1 12}} {{{custom.lat 6 1 7} {custom.lat 10 1 11}} 0xc00030d2f0 <nil> <nil>} x <nil>})] %!s(*ast.Block=&{{{custom.lat 13 1 14} {custom.lat 901 49 1}} [0xc00026e840] 0xc0003c6120}) %!s(*ast.TopDef=&{{{custom.lat 0 1 1} {custom.lat 901 49 1}} <nil> 0xc0003c6120 0xc00038e280}) int â†’ int}
Add intro for &{{custom.lat:50:17 custom.lat:50:21} %!s(*string=<nil>) %!s(*int64=<nil>) %!s(*string=<nil>) %!s(*bool=0xc0002fd619) %!s(*ast.Expression=<nil>) %!s(*ast.Index=&{{{custom.lat 930 50 17} {custom.lat 934 50 21}} 0xc0003e8820 <nil> 0xc0003e88c0}) %!s(*ast.PrimaryInvalid=<nil>) <nil>}
Add intro for &{{custom.lat:51:9 custom.lat:51:10} %!s(*string=0xc00030d750) %!s(*int64=<nil>) %!s(*string=<nil>) %!s(*bool=<nil>) %!s(*ast.Expression=<nil>) %!s(*ast.Index=&{{{custom.lat 944 51 9} {custom.lat 945 51 10}} 0xc0003e8be0 <nil> 0xc0003e8c80}) %!s(*ast.PrimaryInvalid=<nil>) <nil>}
Add intro for &{{custom.lat:52:16 custom.lat:52:17} %!s(*string=<nil>) %!s(*int64=0xc0002fd5d8) %!s(*string=<nil>) %!s(*bool=<nil>) %!s(*ast.Expression=<nil>) %!s(*ast.Index=&{{{custom.lat 964 52 16} {custom.lat 965 52 17}} 0xc0003e8f00 <nil> 0xc0003e8fa0}) %!s(*ast.PrimaryInvalid=<nil>) <nil>}
Add intro for &{{custom.lat:54:16 custom.lat:54:17} %!s(*string=<nil>) %!s(*int64=0xc0002fd608) %!s(*string=<nil>) %!s(*bool=<nil>) %!s(*ast.Expression=<nil>) %!s(*ast.Index=&{{{custom.lat 995 54 16} {custom.lat 996 54 17}} 0xc0003e9540 <nil> 0xc0003e95e0}) %!s(*ast.PrimaryInvalid=<nil>) <nil>}
Add intro for &{{custom.lat:49:1 custom.lat:59:1} {{custom.lat:49:1 custom.lat:49:5} %!s(*string=0xc00030d560) %!s(*ast.Accessor=<nil>) <nil>} main [] %!s(*ast.Block=&{{{custom.lat 912 49 12} {custom.lat 1008 59 1}} [0xc00026ec60 0xc00026ed10] 0xc0003c6360}) %!s(*ast.TopDef=&{{{custom.lat 901 49 1} {custom.lat 1008 59 1}} <nil> 0xc0003c6360 0xc00038e280}) <nil>}
Add intro for &{{custom.lat:49:1 custom.lat:59:1} {{custom.lat:49:1 custom.lat:49:5} %!s(*string=0xc00030d560) %!s(*ast.Accessor=<nil>) <nil>} main [] %!s(*ast.Block=&{{{custom.lat 912 49 12} {custom.lat 1008 59 1}} [0xc00026ec60 0xc00026ed10] 0xc0003c6360}) %!s(*ast.TopDef=&{{{custom.lat 901 49 1} {custom.lat 1008 59 1}} <nil> 0xc0003c6360 0xc00038e280}) void_arg â†’ int}
START FLOW ANALYSIS
REF as=[] up=[] de=[] us=[]
REF as=[] up=[] de=[] us=[]
GET USED VARIABLES PRIMARY: NONE
GET USED VARIABLES PRIMARY: NONE
REF as=[] up=[] de=[] us=[]
REF as=[] up=[] de=[] us=[]
KURWA MAC PIERDOLONA W DUPE: 1
=> NODE[1]: *generic_ast.VirtualNode{ENTRY}
KURWA MAC PIERDOLONA W DUPE: 2
=> NODE[2]: *ast.Return{return 1;}
KURWA MAC PIERDOLONA W DUPE: 3
=> NODE[3]: *generic_ast.VirtualNode{EXIT}
!> (sibling pred/succ 0/1) CANNOT Merge 2 into 1
!> (block pred/succ 2/0) CANNOT Merge 3 into ANY
REF as=[temp_10] up=[temp_10] de=[temp_10] us=[]
RENAME IN STATMENT :DD []
RENAME IN STATMENT :C [] (with map[] and map[])
REF as=[] up=[] de=[] us=[temp_10]
RENAME IN STATMENT :DD []
RENAME IN STATMENT :C [] (with map[] and map[])
CFG TYPE *generic_ast.VirtualNode
CFG TYPE *ir.IRExit
CFG TYPE *generic_ast.VirtualNode
CFG TYPE *generic_ast.VirtualNode
CFG TYPE *ir.IRConst
Fold done (IR):


ENTIRE CODE IR:

Function Int32 r()
{
  block2: ; block
    Int32 temp_10 = Const(1) [] [temp_10] Meta{Target:Allocation(), Context:Allocation()} (begin 0:0) ; Const int 1
    Exit Int32 (temp_10) [temp_10] [] Meta{Target:Allocation(), Context:Allocation()} (begin 0:0)
  
}


ENTIRE GRAPH IR:

REF as=[] up=[] de=[] us=[]
REF as=[] up=[] de=[] us=[]
REF as=[] up=[] de=[] us=[]
REF as=[] up=[] de=[] us=[temp_10]
REF as=[temp_10] up=[temp_10] de=[temp_10] us=[]
    Block:   3([<-2 <-4 as=[] up=[] de=[] us=[] [] {} EXIT]) starts at (line -3, col -3)    and ends at (line -3, col -3)   
    Block:   4([->3 as=[] up=[] de=[] us=[] [] {} END]) starts at (line -2, col -2)    and ends at (line -2, col -2)   
    Block:   1([->5 as=[] up=[] de=[] us=[] [] {} ENTRY]) starts at (line -1, col -1)    and ends at (line -1, col -1)   
    Block:   2([<-5 ->3 as=[] up=[] de=[] us=[temp_10] [temp_10] {} Exit Int32 (temp_10)]) starts at (line 3, col 9)      and ends at (line 4, col 5)     
    Block:   5([<-1 ->2 as=[temp_10] up=[temp_10] de=[temp_10] us=[] [] {2, 3} Int32 temp_10 = Const(1)]) starts at (line 3, col 16)     and ends at (line 3, col 17)    
    1 | 
    2 | Yeah.
START FLOW ANALYSIS
REF as=[] up=[] de=[] us=[]
REF as=[] up=[] de=[] us=[]
GET USED VARIABLES PRIMARY: NONE
GET USED VARIABLES PRIMARY: NONE
GET USED VARIABLES PRIMARY: NONE
GET USED VARIABLES PRIMARY: NONE
REF as=[x] up=[x] de=[] us=[]
GET USED VARIABLES PRIMARY: NONE
GET USED VARIABLES PRIMARY: NONE
REF as=[] up=[] de=[] us=[]
GET USED VARIABLES PRIMARY: VAR[x]
GET USED VARIABLES PRIMARY: VAR[x]
GET USED VARIABLES PRIMARY: NONE
GET USED VARIABLES PRIMARY: NONE
GET USED VARIABLES PRIMARY: NONE
GET USED VARIABLES PRIMARY: NONE
GET USED VARIABLES PRIMARY: VAR[x]
GET USED VARIABLES PRIMARY: VAR[x]
REF as=[] up=[] de=[] us=[x]
GET USED VARIABLES PRIMARY: NONE
GET USED VARIABLES PRIMARY: NONE
REF as=[] up=[] de=[] us=[]
REF as=[] up=[] de=[] us=[]
KURWA MAC PIERDOLONA W DUPE: 1
=> NODE[1]: *generic_ast.VirtualNode{ENTRY}
KURWA MAC PIERDOLONA W DUPE: 3
=> NODE[3]: *ast.Declaration{boolean x = true}
KURWA MAC PIERDOLONA W DUPE: 5
=> NODE[5]: *ast.If{if (x) {
  return 4;
} else {
  return 9;
}}
[?] If contents: *ast.Return{return 4;}
KURWA MAC PIERDOLONA W DUPE: 4
=> NODE[4]: *ast.Return{return 4;}
KURWA MAC PIERDOLONA W DUPE: 7
=> NODE[7]: *generic_ast.VirtualNode{EXIT}
KURWA MAC PIERDOLONA W DUPE: 6
=> NODE[6]: *ast.Return{return 9;}
!> (sibling pred/succ 0/1) CANNOT Merge 3 into 1
!> (block pred/succ 1/2) CANNOT Merge 5 into ANY
!> (sibling pred/succ 1/2) CANNOT Merge 4 into 5
!> (block pred/succ 3/0) CANNOT Merge 7 into ANY
!> (sibling pred/succ 1/2) CANNOT Merge 6 into 5
REF as=[temp_10] up=[temp_10] de=[temp_10] us=[]
RENAME IN STATMENT :DD []
RENAME IN STATMENT :C [] (with map[] and map[])
REF as=[x] up=[x] de=[x] us=[temp_10]
RENAME IN STATMENT :DD []
RENAME IN STATMENT :C [] (with map[x:x_3_0] and map[])
REF as=[] up=[] de=[] us=[x]
RENAME IN STATMENT :DD []
RENAME IN STATMENT :C [] (with map[] and map[x:x_3_0])
REF as=[temp_30] up=[temp_30] de=[temp_30] us=[]
RENAME IN STATMENT :DD []
RENAME IN STATMENT :C [] (with map[] and map[x:x_3_0])
REF as=[] up=[] de=[] us=[temp_30]
RENAME IN STATMENT :DD []
RENAME IN STATMENT :C [] (with map[] and map[x:x_3_0])
REF as=[temp_40] up=[temp_40] de=[temp_40] us=[]
RENAME IN STATMENT :DD []
RENAME IN STATMENT :C [] (with map[] and map[x:x_3_0])
REF as=[] up=[] de=[] us=[temp_40]
RENAME IN STATMENT :DD []
RENAME IN STATMENT :C [] (with map[] and map[x:x_3_0])
IRIF BUILD FLOW
CFG TYPE *generic_ast.VirtualNode
CFG TYPE *generic_ast.VirtualNode
CFG TYPE *ir.IRCopy
CFG TYPE *ir.IRConst
CFG TYPE *ir.IRIf
CFG TYPE *ir.IRExit
CFG TYPE *ir.IRExit
CFG TYPE *generic_ast.VirtualNode
CFG TYPE *ir.IRConst
CFG TYPE *ir.IRConst
Fold done (IR):


ENTIRE CODE IR:

Function Int32 main()
{
  block3: ; block
    Bit temp_10 = Const(1) [] [temp_10] Meta{Target:Allocation(), Context:Allocation()} (begin 0:0) ; Const boolean true
    Bit x_3_0 = Copy(temp_10) [temp_10] [x_3_0] Meta{Target:Allocation(), Context:Allocation()} (begin 0:0) ; Assign variable x
  
  block5: ; block
    If Bit x_3_0 jump to block4 else block6 [x_3_0] [] Meta{Target:Allocation(), Context:Allocation()} (begin 0:0) ; If condition
  
  block4: ; block
    Int32 temp_30 = Const(4) [] [temp_30] Meta{Target:Allocation(), Context:Allocation()} (begin 0:0) ; Const int 4
    Exit Int32 (temp_30) [temp_30] [] Meta{Target:Allocation(), Context:Allocation()} (begin 0:0)
  
  block6: ; block
    Int32 temp_40 = Const(9) [] [temp_40] Meta{Target:Allocation(), Context:Allocation()} (begin 0:0) ; Const int 9
    Exit Int32 (temp_40) [temp_40] [] Meta{Target:Allocation(), Context:Allocation()} (begin 0:0)
  
}


ENTIRE GRAPH IR:

REF as=[] up=[] de=[] us=[]
REF as=[] up=[] de=[] us=[]
REF as=[] up=[] de=[] us=[]
REF as=[x_3_0] up=[x_3_0] de=[x_3_0] us=[temp_10]
REF as=[temp_10] up=[temp_10] de=[temp_10] us=[]
REF as=[] up=[] de=[] us=[x_3_0]
REF as=[] up=[] de=[] us=[temp_30]
REF as=[temp_30] up=[temp_30] de=[temp_30] us=[]
REF as=[] up=[] de=[] us=[temp_40]
REF as=[temp_40] up=[temp_40] de=[temp_40] us=[]
    Block:   8([<-6 <-7 <-1 as=[] up=[] de=[] us=[] [] {} EXIT]) starts at (line -3, col -3)    and ends at (line -3, col -3)   
    Block:   1([->8 as=[] up=[] de=[] us=[] [] {} END]) starts at (line -2, col -2)    and ends at (line -2, col -2)   
    Block:   2([->4 as=[] up=[] de=[] us=[] [] {} ENTRY]) starts at (line -1, col -1)    and ends at (line -1, col -1)   
    Block:   3([<-4 ->5 as=[x_3_0] up=[x_3_0] de=[x_3_0] us=[temp_10] [temp_10] {5, 6, 7, 8, 9, 10} Bit x_3_0 = Copy(temp_10)]) starts at (line 50, col 13)    and ends at (line 50, col 21)   
    Block:   4([<-2 ->3 as=[temp_10] up=[temp_10] de=[temp_10] us=[] [] {5, 6, 7, 8, 9, 10, 3} Bit temp_10 = Const(1)]) starts at (line 50, col 17)    and ends at (line 50, col 21)   
    Block:   5([<-3 ->9 ->10 as=[] up=[] de=[] us=[x_3_0] [x_3_0] {} If Bit x_3_0 jump to block4 else block6]) starts at (line 51, col 5)     and ends at (line 56, col 1)    
    Block:   6([<-9 ->8 as=[] up=[] de=[] us=[temp_30] [temp_30] {} Exit Int32 (temp_30)]) starts at (line 52, col 9)     and ends at (line 53, col 5)    
    Block:   9([<-5 ->6 as=[temp_30] up=[temp_30] de=[temp_30] us=[] [] {6, 8} Int32 temp_30 = Const(4)]) starts at (line 52, col 16)    and ends at (line 52, col 17)   
    Block:   7([<-10 ->8 as=[] up=[] de=[] us=[temp_40] [temp_40] {} Exit Int32 (temp_40)]) starts at (line 54, col 9)     and ends at (line 55, col 5)    
    Block:  10([<-5 ->7 as=[temp_40] up=[temp_40] de=[temp_40] us=[] [] {7, 8} Int32 temp_40 = Const(9)]) starts at (line 54, col 16)    and ends at (line 54, col 17)   
    1 | 
    2 | Yeah.
Try to allocate register? name: temp_10, size: 4 of [map[ECX:0xc0003e37d0 EDX:0xc0003e3800]]
FUNCTION SIZE: 0
Try to allocate register? name: temp_10, size: 4 of [map[ECX:0xc0003e3c80 EDX:0xc0003e3cb0]]
Try to allocate register? name: x_3_0, size: 4 of [map[ECX:0xc0003e3c80 EDX:0xc0003e3cb0]]
Try to allocate register? name: temp_30, size: 4 of [map[ECX:0xc0003e3c80 EDX:0xc0003e3cb0]]
Try to allocate register? name: temp_40, size: 4 of [map[ECX:0xc0003e3c80 EDX:0xc0003e3cb0]]
FUNCTION SIZE: 0
?BASED?
Function Int32 r()
{
    block2: ; block
      Int32 temp_10 = Const(1) [] [temp_10] Meta{Target:Allocation(temp_10: Register[ECX(size=4)]), Context:Allocation(temp_10: Register[ECX(size=4)])} (begin 0:0) ; Const int 1
      Exit Int32 (temp_10) [temp_10] [] Meta{Target:Allocation(), Context:Allocation(temp_10: Register[ECX(size=4)])} (begin 0:0)
    
}

Function Int32 main()
{
    block3: ; block
      Bit temp_10 = Const(1) [] [temp_10] Meta{Target:Allocation(temp_10: Register[ECX(size=4)]), Context:Allocation(temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)], temp_30: Register[EDX(size=4)], temp_40: Register[ECX(size=4)])} (begin 0:0) ; Const boolean true
      Bit x_3_0 = Copy(temp_10) [temp_10] [x_3_0] Meta{Target:Allocation(x_3_0: Register[EDX(size=4)]), Context:Allocation(temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)], temp_30: Register[EDX(size=4)], temp_40: Register[ECX(size=4)])} (begin 0:0) ; Assign variable x
    
    block5: ; block
      If Bit x_3_0 jump to block4 else block6 [x_3_0] [] Meta{Target:Allocation(), Context:Allocation(temp_40: Register[ECX(size=4)], temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)], temp_30: Register[EDX(size=4)])} (begin 0:0) ; If condition
    
    block4: ; block
      Int32 temp_30 = Const(4) [] [temp_30] Meta{Target:Allocation(temp_30: Register[EDX(size=4)]), Context:Allocation(temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)], temp_30: Register[EDX(size=4)], temp_40: Register[ECX(size=4)])} (begin 0:0) ; Const int 4
      Exit Int32 (temp_30) [temp_30] [] Meta{Target:Allocation(), Context:Allocation(temp_40: Register[ECX(size=4)], temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)], temp_30: Register[EDX(size=4)])} (begin 0:0)
    
    block6: ; block
      Int32 temp_40 = Const(9) [] [temp_40] Meta{Target:Allocation(temp_40: Register[ECX(size=4)]), Context:Allocation(temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)], temp_30: Register[EDX(size=4)], temp_40: Register[ECX(size=4)])} (begin 0:0) ; Const int 9
      Exit Int32 (temp_40) [temp_40] [] Meta{Target:Allocation(), Context:Allocation(temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)], temp_30: Register[EDX(size=4)], temp_40: Register[ECX(size=4)])} (begin 0:0)
    
}


%!s(MISSING)FUNCTION SIZE: 0
FUNCTION SIZE: 0

AFTER PREPROCESSING STEP:
Function Int32 r()
{
    block2: ; block
      Int32 temp_10 = Const(1) [] [temp_10] Meta{Target:Allocation(temp_10: Register[ECX(size=4)]), Context:Allocation(temp_10: Register[ECX(size=4)])} (begin 0:0) ; Const int 1
      Exit Int32 (temp_10) [temp_10] [] Meta{Target:Allocation(), Context:Allocation(temp_10: Register[ECX(size=4)])} (begin 0:0)
    
}

Function Int32 main()
{
    block3: ; block
      Bit temp_10 = Const(1) [] [temp_10] Meta{Target:Allocation(temp_10: Register[ECX(size=4)]), Context:Allocation(temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)], temp_30: Register[EDX(size=4)], temp_40: Register[ECX(size=4)])} (begin 0:0) ; Const boolean true
      Bit x_3_0 = Copy(temp_10) [temp_10] [x_3_0] Meta{Target:Allocation(x_3_0: Register[EDX(size=4)]), Context:Allocation(temp_40: Register[ECX(size=4)], temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)], temp_30: Register[EDX(size=4)])} (begin 0:0) ; Assign variable x
    
    block5: ; block
      If Bit x_3_0 jump to block4 else block6 [x_3_0] [] Meta{Target:Allocation(), Context:Allocation(temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)], temp_30: Register[EDX(size=4)], temp_40: Register[ECX(size=4)])} (begin 0:0) ; If condition
    
    block4: ; block
      Int32 temp_30 = Const(4) [] [temp_30] Meta{Target:Allocation(temp_30: Register[EDX(size=4)]), Context:Allocation(temp_30: Register[EDX(size=4)], temp_40: Register[ECX(size=4)], temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)])} (begin 0:0) ; Const int 4
      Exit Int32 (temp_30) [temp_30] [] Meta{Target:Allocation(), Context:Allocation(temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)], temp_30: Register[EDX(size=4)], temp_40: Register[ECX(size=4)])} (begin 0:0)
    
    block6: ; block
      Int32 temp_40 = Const(9) [] [temp_40] Meta{Target:Allocation(temp_40: Register[ECX(size=4)]), Context:Allocation(temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)], temp_30: Register[EDX(size=4)], temp_40: Register[ECX(size=4)])} (begin 0:0) ; Const int 9
      Exit Int32 (temp_40) [temp_40] [] Meta{Target:Allocation(), Context:Allocation(temp_10: Register[ECX(size=4)], x_3_0: Register[EDX(size=4)], temp_30: Register[EDX(size=4)], temp_40: Register[ECX(size=4)])} (begin 0:0)
    
}


%!s(MISSING)
==========END=========

[K[36mGenerate compiled code using backend: X86 Jasmine backend[m  / [K Code Generation Error : Build command has failed
    | On command:  gcc $BUILD_DIR/code.o -o $BUILD_DIR/code_exe 
    |     INPUT_FILE_NAME = custom.lat
    |     INPUT_FILE_LOC = .
    |     INPUT_FILE_BASE = custom
    |     BUILD_DIR = /var/folders/xp/sc_32rwj2z53j0gkvdphvsjh0000gp/T/_compile_custom.lat2878112179
    |     ROOT = /Users/pstyczynski/instant-compiler-go
    | Error: Output contains errors
    | Program output: 
    |> 
    |> Undefined symbols for architecture x86_64:
    |>   "_main", referenced from:
    |>      implicit entry/start for main executable
    |> ld: symbol(s) not found for architecture x86_64
    |> clang: error: linker command failed with exit code 1 (use -v to see invocation)
    |> 

